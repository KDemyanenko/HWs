fn main() {
    // Заповнив порожнє місце, вказавши правильний тип масиву: [i32; 5] (5 елементів типу i32)
    let arr: [i32; 5] = [1, 2, 3, 4, 5];

    // Змінив 4 на 5, щоб відповідати довжині масиву
    assert!(arr.len() == 5);

    println!("Success!");
}

----------------------------------------------------------------------------------------
fn main() {
    // We can ignore parts of the array type or even the whole type, let the compiler infer it for us
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];
    
    // Заповнив порожнє місце, вказавши розмір масиву у байтах: 3 елементи * 4 байти кожен
    // 3 chars * 4 bytes per char = 12 bytes
    assert!(std::mem::size_of_val(&arr) == 12);

    println!("Success!");
}

----------------------------------------------------------------------------------------
fn main() {
    // Заповнив порожнє місце, щоб ініціалізувати масив з 100 елементів, усі з яких дорівнюють 1
    let list: [i32; 100] = [1; 100];

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!("Success!");
}

----------------------------------------------------------------------------------------
fn main() {
    // Змінив '3' на 3, щоб всі елементи масиву були одного типу (i32)
    let _arr = [1, 2, 3];

    println!("Success!");
}

----------------------------------------------------------------------------------------
fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[0]; // Змінив індекс з 1 на 0, щоб отримати перший елемент 'a'

    assert!(ele == 'a');

    println!("Success!");
}

----------------------------------------------------------------------------------------
fn main() {
    let names = [String::from("Sunfei"), "Sunface".to_string()];
    
    let name0 = names.get(0).unwrap();

    // Змінив індекс з 2 на 1, щоб отримати другий елемент масиву
    let _name1 = &names[1]; 

    println!("Success!");
}

